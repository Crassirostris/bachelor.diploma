\section{Полнотекстовый поиск}

\subsection{Введение}

Оговоримся заранее, что интересующие нас данные представлены в виде \textbf{документов}, каждый из которых имеет набор \textbf{полей}, некоторых свойств, значения которых принадлежат некоторому домену. Для удобства легче всего считать, что все поля~--- байтовые строки. Это представление удобно тем, что естественно для данных, представимых внутри компьютера и кроме того, лексикографический порядок байтовых массивов соотвествует естественному порядку чисел, дат и лексикографическому порядку строк в представлении UTF-16. Также удобно считать, что одному и тому же полю может соотвествовать несколько значений. Пара (поле, значение) называется \textbf{термом} и обладает семантикой слова в тексте.

Любой документ можно привести к такой форме. Даты например при этом переводятся в числа, а числа в байтовые строки фиксированной длины, соответсвующей размерности числа. Процесс приведения текста чуть более сложен и включет в себя две стадии~--- токенизирование, когда текст превращаеся в набор слов-токенов, каждый из которых затем анализируется, то есть приводится к нормальной форме. Для естественных языков это может быть например выделение корня из слова. Морфологический анализ слов является отдельной задачей, которая используется при построени полнотекстовых индексов, но которую мы не будем подробно затрагивать далее в тексте.

После того, как каждый документ приведен к форме набора термов, можно составить так называемые прямой и обратный индексы. Прямой индекс, который мы можем во многих формах наблюдать в реальности, отображает документ в виде какого-то уникального индитификатора, например абстрактного номера, в набор термов. Обратный индекс нужен для противоположной задачи, отобразить терм в набор документов, в которых он встречается. После того, как мы построили эти индексы, мы может обрабатывать запросы, включающие в себя термы, их отрицание и логические связки.

% TODO insert a picture?

Такой набор возможностей уже позволяет достаточно полно обрабатывать специальные и полнотекстовые запросы, то есть запросы, также сформулированные на естественном языке. С такими запросами необходимо проделать ту же процедуру, что и с исходными документами, преобразовав их к набору термов, затем по каждому терму получить множество документов, которые соотвествуют терму, и после этого применить некоторые теоретико-множественные операции.

Отдельная задача состоит в ранжировании выборки, то есть сортировке формально подходящих документов по убыванию релевантности документа запросу. В данной области опять же существует множество подходов, которые обычно состоят в подсчете некоторой метрики для каждого документа, зависящей от параметров запроса и индекса, по которой и производится сортировка. Примерами может служить метрика TF-IDF, берущая свое начало в работах Питера Луна\footnote{TODO} и Карена Джоунса\footnote{TODO}, или PageRank\footnote{TODO}, разработаная на заре поискового движка Google, особенная тем, что использует информацию, не связанную напрямую с содержанием текста.

Кроме полнотекстовых запросов и запросов, вручную собраных из термов и логических связок, существуют и другие виды, например fuzzy search, который может находить слова, которые не полностью совпадают, исключая таким образом, некоторые опечатки или особенности написания, или поиск по регулярному выражению или поиск по цельной фразе. Опять же, каждый вид поиска является по отдельности большой задачей, которая может исследоваться изолированно и исследуется и находятся решения, о которых мы не будет подробно вести речь.

Важным термином, связанным с полнотекстовым поиском, является так называемый Real Time поиск и Near Real Time (NRT) поиск. Данные термины связаы с тем, что если у нас есть непрерывный процесс генерации и соотвественно индексации новых данных, то может быть задержка межд тем, как мы проиндексировали документ в системе и тем, как мы теоретически можем его получить в составе поисковой выдачи. Это может быть связано с техническими особенностями построения индекса. Real Time поиск гарантирует, что такой задержки не существует и после того, как мы получили так или иначе подтверждение о том, что запрос на индекацию завершился успешно, документ гарантированно можно будет найти соотвествующим поисковым запросом. NRT формально не определяется и предполагает, что задержка, хотя и существует, достаточно мала и незаметна с точки зрения пользователя. Свойство RT или NRT очень желательны в системе, так как обеспечивает незамедлительную обратную связь пользователю на его действия над данными в системе.

\subsection{Масштабируемость}

Иногда данных в системе настолько много, что они физически не вмещаются на одно устройство, или поток запросов становится настолько высок, что один сервер не справляется с такой нагрузкой, в этом случае применяют стратегии горизонтального масштабирования, а именно \textbf{шардинг} и \textbf{репликацию}.

Шардинг~--- разделение данных на непересекающиеся части, каждая из которых работает независимо, чаще всего независимо по вычислительным ресурсам. Каждый шард представляет из себя отдельный индекс, к которому применяется запрос, по результатом которого получается выборка. После того, как выборка, соотвествующая данному запросу, была получена на каждом шарде, результаты объединяются в конечную выборку, которая и является ответом на запрос к шардированному индексу. Чаще всего объединение происходит по метрике релевантности, которая была рассмотрена выше, вследствие чего, при необходимости получения запроса размера $N$ при $K$ шардах, нельзя обойтись без того, чтобы не запросить $N$ наиболее релевантных документов с каждого шарда, так как мы не знаем, какие из них в итоге попадут в выборку. Это в $K$ раз увеличивает количество документов, которые будут извлечены из индекса, переданны в среде передачи данных и аггрегированы на сервере, обслуживающем клиентский запрос.

Таким образом, шардинг позволяет разделить индекс на более маленькие части, каждая из которых является подъемной для вычислительной машины, на которой расположен шард, что в свою очередь позволяет строить индексы колоссальных размеров. Но в свою очередь данный процесс отрицательно сказывается на производительности системы при обращении к ней пользователей.

Чтобы производить шардинг, каждый документ также должен обладать некоторым внешним по отношению к индексу параметром, в некоторых источниках упоминающимся как роутинг, по которому происходит выбор, в какой шард попадет этот документ. Роутинг не обязательно должен быть уникальным для каждого документа, но он должен обладать двумя важными свойствами. Во-первых, роутинг должен быть равномерно распределен по документам, так как иначе создается дизбаланс в нагрузке и в какой-то момент может получиться так, что при обработке запроса все шарды, кроме одного, самого большого, простаивают. Во-вторых, роутинг не должен меняться при изменении документа, так как иначе изменение может оказаться некорректным.

Репликация~--- копирование данных на независимые вычислительные мощности. Зачастую применяется в совокупности с шардированием, когда исходных индекс разбивается на несколько независимых частей, каждая из которых реплецируется. Репликация позволяет достигнуть двух важных вещей. Во-первых, используя ту или иную технологию распределеня нагрузки между репликами, мы можем получить улучшения производительности системы, за счет того, что запросы к одному и тому же индексу исполняются на разных вычислительных мощностях. Это, например, может компенсировать проседание производительности при шардировании. Во-вторых, репликация данных позволяет обеспечить большую степень отказоустойчивости, об этом будет подробно рассказано ниже.

Однако, с увеличением производительности при поиске происходит уменьшение производительности при индексации, так как нам необходимо каждый раз записывать новые данные не в один индекс, а в каждую реплику, которых может быть 2 и более. Кроме того, наличие реплик может привести к проблемам, известным в области распределенных вычислений как stale reads, когда запросы на разные реплики дают разные резульататы, так как запись прошла на одной реплике, но не прошла на другой. Об этом также будет сказано ниже.

\subsection{Отказоустойчивость}

В реальном мире компьютеры, на которых запускается программное обеспечение зачастую отказывает в силу тех или иных причин, по мере роста и масштабирования системы вероятность того, что в данный промежуток времени произойдет сбой, растет очень быстро, поэтому важно, чтобы система сохраняла работоспособность даже при условии, что произошел сбой, возможно даже не единственный.

Основная мера по предотвращению такой ситуации~--- создание распределенной системы без единой точки отказа, когда каждый функциональный узел дублируется на независимых вычислительных машинах. Таким образом, чтобы соотвествовать стандартам качества и отказоустойчивости, необходимо, чтобы система, выполняющая поисковые запросы, была распределенной и умела реагировать на экстренные ситуации.

Если шард поискового индекса будет существовать в кластере в единственном экземпляре, то об отказоустойчивости не может идти речи, так как выход из строя компьютера, на котором расположен этот экземпляр приведет к невозможности обслуживания запросов к индексу, которому принадлежит этот шард. Таким образом, краеугольный камень работы поискового движка в условиях распределенности~--- репликация данных.

Но из-за появления структуры данных, распределенной на нексколько компьютеров в сети, возникает необходимость в гарантии консистентности системы в смысле корректности ее поведения с точки зрения внешнего наблюдателя. Как мы обсуждалии ранее, для нашего применения система должна быть CP, то есть быть устойчива к разрывам связи в сети и обеспечивать линеаризуемость операций над данными.

\clearpage
