\section{Распределенные системы}

Введем базовые понятия из области распределенных систем

\subsection{Модели косистентности}

Прежде всего необходимо ввести понятие "истории", как некоторой последовательности событий, упорядоченной в абсолютном времени, которые совершались с системой. При этом события не происходят мгновенно, каждое событие имеет время вызова (invocation) и время завершения (response).

Для примера упростим на время модель выше и скажем, что операции все-таки происходят мгновенно. Теперь рассмотрим логический поток управления в программе, который работает с одной переменной. Историей в данном случае будет например последовательность операций

$$ (write(3), read(3), write(5)) $$

где $write(x)$ обозначает запись в переменную числа $x$, а $read(x)$ означает чтение из переменной числа $x$. Также историей будет последовательность

$$ (write(10), read(42)) $$

Несмотря на то, что формально последний пример является историей, интуитивно мы понимает, что такого не могло произойти. Множество допустимых, корректных историй, заданное явно или с помощью правил, называется моделью консистентности. Чем больше возможных историй допускает модель, тем она слабее, и наоборот, чем меньше возможных историй допускает модель, тем она строже (или сильнее, что означает то же самое). Введем несколько самых строгих прикладных моделей консистентности.

\subsubsection{Линеаризумость}

Допустим, что в системе есть единственное глобальное состояние, с которым взаимодействует каждый процесс. Кроме того, все операции, допустимые в системе, являются атомарными, то есть происходят не одновременно с другими операциями. Кроме того, логично будет допустить, что операции выполняются не раньше, чем она была вызваны и не позже, чем был получен ответ. Истории, допустимые в такой модели называются линеаризуемыми. Можно представить, что все операции выполнялись мгновенно в какой-то момент времени между своим вызовом и завершением, образуя линейную историю атомарных изменений единого состояния.

Из таких временных рамок следует, например, что прочитав состояние после успешно завершенной записи, мы обнаружим не более старое состояние, чем было записано. Такие ограничения являются естественными для понимания и поэтому линеаризуемость выбрана за основу многих параллельных и распределенных программных конструкций. Например, volatile переменные в Java, атомы в Clojure и переменные в javascript являются линеаризуемыми.

На самом деле "единое глобальное состояние" не обязательно должно быть расположено на одном вычислительном узле. Более того, операции не обязательно должны быть атомарными. Состояние может быть распределено на многих узлах, его изменение может состоять из нескольких шагов. Важно лишь то, чтобы извне история применения операций казалась эквивалентной истории атомарных изменений единого состояния. Часто, линеаризуемая система состоит из более мелких частей, каждая из которых линеаризуема и свою очередь состоит из линеаризуемых частей, и так далее до линеаризуемых на аппаратном уровне примитивов.

\subsubsection{Сериализуемость}

Сериализуемость во многом похожа на линеаризуемость, но в данном случае нет ограничения на единое состояние. Важно лишь то, чтобы история операций была эквивалентна некоторому последовательному атомарному выполнению. Кроме того, времена вызова и завершения не обязаны коррелировать со временем действительного выполнения.

С одной стороны, данная модель консистентности достаточно слабая, так как разрешает множество перестановок операций, с другой стороны, она отсекает большой класс историй за счет требования линейности. Для примера, история операций

$$ (read(3), writeif(2, 1), writeif(3, 2), write(1)) $$

допускает единственный возможный порядок выполнения (операция $writeif(x, y)$ записывает в состояние $x$, если в данный момент оно $y$).

Недостатком сериализуемости самой по себе является то, что из-за отсутствия ограничения на время выполнения операции, теоретически может произойти так, что какое-то изменение будет бесконечно откладываться на будущее и никогда не исполнится. На практике это приведет к фактической потери транзакции, что, конечно же, мало когда допустимо.

\subsubsection{Строгая сериализуемость}

Чаще, когда говорят о желаемой модели консистентности, имеют в виде строгую сериализуемость. Сохраняя все свойства сериализуемости, она также накладывает ограничение на временные рамки выполнения операций, обеспечивая важное почти во всех приложениях свойство гарантии прогресса. Таким образом, все успешно дошедшие до системы операции будут выполнены за конечное время.

Что интересно, на практике нередко ограничиваются более слабой моделью консистентности и то, что подразумевается под сериализуемостью на самом деле не дает таких же сильных гарантий.

\subsection{CAP-теорема}

В 2000 году на конференции PODC Эриком Брювером была выдвинута так называемая гипотеза Брювера, утверждающая, что невозможно создать систему, которая была бы одновременно консистентная (C, consistency), доступна (A, availability) и устойчива к разделению сети (P, partition tolerance)\cite{brewer}. Позже, в 2002 была выпущена работа за авторством Сета Гильберта и Нэнси Линч\cite{cap-proof}, в которой формально было сформулирована и доказана следующая теорема:

\begin{theorem}
	В условиях асинхронной сети невозможно создать объект, поддерживающий операции чтения и записи, который бы гарантировал следующие свойства:
	
	\begin{itemize}
		\item Доступность
		\item Атомарная консистентность
	\end{itemize}
	
	для всех совершенных запросов (включая те, в которых сообщение было потеряно).
\end{theorem}

Которая сейчас и называется CAP-теоремой. Для понимания, как это соотносится с исходными понятиями, необходимо формально ввести, что такое доступность, консистентность и устойчивость к разделению сети.

\subsubsection{Консистентность}

Атомарная консистеность понимается как линеаризуемость, упомянутая выше, то есть множество допустимых историй, каждую из которых можно представить в виде последовательности атомарных изменений единого состояния, причем все изменения происходили мгновенно в момент времени между вызовом и завершением.

\subsubsection{Доступность}

Доступность распределенной системы означает, что на любой запрос, полученный работающим узлом в кластере должен быть сгенерирован ответ за конечное время. Это означает, что алгоритм, положенный в основу работы распределенной системы не должен допускать бесконечно долгого ожидания результата. Сообщение об ошибке не считается ответом, то есть система, которая может бесконечно долго отвечать ошибкой на запрос не является доступной в данном смысле.

\subsubsection{Устойчивость к разделению сети/Асинхронная сеть}

Важно понимать, что данный пункт не накладывает ограничений на алгоритм в основе распределенной системы. P в аббревиатуре CAP хоть и расшифровывается как устойчивость к разделению сети, но на самом деле означает то, что в сети допускается любое количество потерянных и задержанных сообщений между узлами.

Легче всего понять это ограничение, если заметить, что почти любая CP система также является CA, так как в условии отсутствия задержек и потерь сообщений несложно добиться доступности. Если бы P было исключительно свойством алгоритма, то данный факт эффективно показывал бы наличие CAP системы, что противоречит теореме.

Также немаловажным выводом является то, что алгоритм, лежащий в основе P системы может рассчитывать только на полученные сообщение и локальные для узла параметры.

\subsection{В применении к задаче}

Исходя из вышесказанного, можно понять, что каждый раз при проектировании системы нам необходимо выбирать, какому классу будет принадлежать наша система, CP или AP. CA не является сколько-нибудь значимым вариантом, так как в реальных системах неизменно случаются разрывы в сети, отказы вычислительных узлов и тому подобное.

Так как приложения в основном имеют дело со сгенерированными пользователем данными, крайне нежелательно было бы их потерять. Отсюда естественным выводом будет всегда в данной работе отдавать предпочтение CP системам.

Существуют сферы и приложения, для которых необходимы AP системы, например часто таковыми являются распределенные системы кеширования. Однако в данном случае подобные возможности не столь ценны.

\clearpage
