\section{Распределенные системы}

Так как впоследствии нам не один раз придется столкнутся с распределенными системами и связанными понятиями, то видится необходимым ввести некоторые термины и описать некоторые модели, с этим связанные.

\subsection{Модели косистентности}

Прежде всего необходимо ввести понятие "истории", как некоторой последовательности событий, упорядоченной в абсолютном времени, которые совершались с системой. Для простоты будем считать, что бывают только запросы на чтение и запросы на запись абстрактного состояния. Состояние может быть как переменной, так и произвольным объектом, так и распределенным по нескольким вычислительным узлам набором данных. Так как мы живем в неидеальном мире, между запросом и ответом проходит какое-то ненулевое количество времени.

Например, историей для одного логического потока управления будет "записать в переменную число 5, прочитать число 5, записать в переменную число 3, прочитать число 3". С интуитивной точки зрения, такая история является корректной, однако для дальнейшего использование видится необходимым формализовать понятия "корректности истории". Набор правил или, что эквивалентно, множество всех возможных историй и есть моделью консистентности, которую мы требуем от системы. Например, если преобразовать пример выше в следующий: "записать в переменную число 5, прочитать число 3", то это будет нарушать набор правил, естественный для последовательной системы, так как перед тем, как прочитать какое-то значение, мы должны его туда сначала записать.

Нас будут интересовать сильные модели консистентности, в том смысле, что для них доказан аналог теоремы, о которой будет подробно рассказано в следующей секции. Среди всех подобных подробно остановимся на сериализуемости, линеаризуемости и сильной сериализуемости, которая по сути является пересечением двух предыдущих.

\subsubsection{Линеаризумость}

Формально говоря, линеаризуемость применима к распределенному регистру и всем эквивалентным ему типам данных, которые почти полностью покрывают весь спектр существующих структур данных. Мы говорим, что история операций линеаризуема, если ее можно представить в виде эквивалентной последовательной истории, в которой операции чтения и записи происходили мнгновенно и атомарно в какой-то момент времени между началом и концом запроса, не выходя за этим рамки. Из этого следует, в частности, что если запись была успешно завершена, то любое чтение после этого прочитает не более старую версию данных. Аналогично, если чтение было успешно завершено, то и любое последовательное чтение может прочитать только эти данные или записанные позднее.

Важным свойством линеаризуемости является локальность этого свойства, если все компоненты системы обладают линеаризуемостью, то и вся система обладает линеаризуемостью. Таким образом, цельная линеаризуемая система может состоять из линеаризуемых компонентов, каждая из которых в свою очередь является линеаризуемой и может состоять из еще более мелких линеаризуемых частей.

\subsubsection{Сериализуемость}

Сериализуемость, в отличии от линеаризуемости, не накладывает ограничения на время выполнения запросов, полностью игнорируя время. История является сериализуемой, если она эквивалентна некоторой корректной синхронной истории при одном логическом потоке выполнения, в которой операции происходили мнгновенно и атомарно. Из-за отсутствия ориентира на время выполнения запроса, некоторые операции могут дожидаться своего выполнения бесконечно долго для обеспечения сериализуемости.

\subsubsection{Строгая сериализуемость}

Из-за свойства сериализуемости откладывать выполнение некоторых запросов в бесконечно далекое будущее, сериализуемость сама по себе не насколько полезна в реальных приложениях. Гораздо чаще когда говорят о желаемой модели консистентности, имеют в виде строгую консистентность, которая, будучи сериализуемостью, позволяет сохранять линейную сериализованную историю выполнения, но в то же время гарантируя прогресс за конечное время.

\subsection{CAP-теорема}

В 2000 году на конференции PODC Эриком Брювером была выдвинута так называемая гипотеза Брювера, утверждающая, что невозможно создать систему, которая была бы одновременно консистентная (C, consistency), доступна (A, availability) и устойчива к разделению сети (P, partition tolerance)\cite{brewer}. Позже, в 2002 была выпущена работа за авторством Сета Гильберта и Нэнси Линч\cite{cap-proof}, в которой формально было сформулированна и доказана следующая теорема:

\begin{theorem}
	В условиях асинхронной сети невозможно создать объект, поддерживающий операции чтения и записи, который бы гарантировал следующие свойства:
	
	\begin{itemize}
		\item Доступность
		\item Атомарная консистентность
	\end{itemize}
	
	для всех совершенных запросов (включая те, в которых сообщение было потеряно).
\end{theorem}

Которая сейчас и называется CAP-теоремой. Для понимания, как это соотносится с исходными понятиями, необходимо формально ввести, что такое доступность, консистентность и устойчивость к разделению сети.

\subsubsection{Консистентность}

Атомарная консистеность понимается как линеаризуемость, упомянутая выше, то есть любая история, которую можно сериализовать так, что любая операция происходит атомарно и мнгновенно в какой-то момент между временем запроса и временем ответа на запрос.

\subsubsection{Доступность}

Доступность распределенной системы означает, что на любой запрос, полученный работающей нодой в кластере должен быть сгенерирован ответ за конечное время. Это означает, что алгоритм, положенный в основу работы распределенной системы не должен допускать бесконечно долгого ожидания результата. Сообщение об ошибке не считается ответом, то есть система, которая может бесконечно долго отвечать ошибкой на запрос не является доступной в данном смысле.

\subsubsection{Устойчивость к разделению сети/Асинхронная сеть}

Данный пункт важен тем, что он не накладывает ограничения на саму систему, алгоритм принятия решений на каждой из реплик, а утверждает, что в передающей среде, которая связывает ноды кластера, могут быть задержки сколь угодно большой продолжительности и может быть потеряно сколько угодно много сообщений. Асинхронная сеть также накладывает ограничение на отсутствие некоторых часов, надежный доступ к которым есть у всех нод, ограничивая вход алгоритма только последовательностью приходящих на него сообщений и локальными параметрами.

\subsection{В применении к задаче}

Исходя из вышесказанного, можно понять, что каждый раз при проектировании системы нам необходимо выбирать, какому классу будет принадлежать наша система, CP или AP. CA не является сколько-нибудь значимым вариантом, так как в реальных системах случаются разрывы в сети, отказы вычислительных узлов и тому подобное, этого не избежать.

Так как каждый раз мы имеет дело с данными, которые в конечном счете будет доступны пользователям и из-за особенностей профессиональной направленности продуктов, для которых разрабатывалась система, рассмотренная в данной работе, надежность превышает по важности временную недоступность и выбор каждый раз делался в сторону CP систем. Существуют сферы и приложения, для которых необходимы AP системы, например системы кеширования, но в данном случае не возникает сомнений в правильности выбора CP системы.

\clearpage
